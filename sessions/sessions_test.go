// Copyright 2025 Vedran Vuk. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
//
// This code was generated by an AI assistant.
package sessions

import (
	"crypto/rand"
	"errors"
	"fmt"
	"math/big"
	"strconv"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

type TestKey string

var keyCounter int64

func newTestKey() (key TestKey) {
	atomic.AddInt64(&keyCounter, 1)
	key = TestKey(generateRandomString(10) + strconv.FormatInt(keyCounter, 10))
	return
}

func generateRandomString(length int) (str string) {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var b = make([]byte, length)
	for i := range b {
		var idx, err = rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
		if err != nil {
			panic(err) // handle error appropriately
		}
		b[i] = charset[idx.Int64()]
	}
	str = string(b)
	return
}

func assertEqual[T comparable](t *testing.T, expected, actual T, msg string) {
	if actual != expected {
		t.Errorf("%s: expected [%v], actual [%v]", msg, expected, actual)
	}
}

func assertNotNil(t *testing.T, actual interface{}, msg string) {
	if actual == nil {
		t.Errorf("%s: should not be nil", msg)
	}
}

func assertNotEmpty(t *testing.T, actual string, msg string) {
	if actual == "" {
		t.Errorf("%s: should not be empty", msg)
	}
}

func assertTrue(t *testing.T, actual bool, msg string) {
	if !actual {
		t.Errorf("%s: should be true", msg)
	}
}

func assertFalse(t *testing.T, actual bool, msg string) {
	if actual {
		t.Errorf("%s: should be false", msg)
	}
}

func assertNoError(t *testing.T, err error, msg string) {
	if err != nil {
		t.Errorf("%s: unexpected error [%v]", msg, err)
	}
}

func assertErrorIs(t *testing.T, err, target error, msg string) {
	if !errors.Is(err, target) {
		t.Errorf("%s: error [%v] is not [%v]", msg, err, target)
	}
}

func assertLessOrEqual(t *testing.T, actual, expected int, msg string) {
	if actual > expected {
		t.Errorf("%s: actual [%d] is not less or equal to expected [%d]", msg, actual, expected)
	}
}

func TestNew(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	assertNotNil(t, sessions, "New Sessions")
	assertEqual(t, 0, sessions.SessionCount(), "Initial SessionCount")
}

func TestAdd(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()

	var sessionID TestKey
	var err error

	sessionID, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session")
	assertNotEmpty(t, string(sessionID), "SessionID should not be empty")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after add")
	assertEqual(t, 1, sessions.UserSessionCount(userID), "UserSessionCount after add")

	_, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session 2")
	_, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session 3")
	_, err = sessions.CreateLinked(userID, time.Minute)
	assertErrorIs(t, err, ErrMaxUserSessions, "Add session 4, max user sessions error")
	assertEqual(t, 3, sessions.SessionCount(), "SessionCount after max user sessions")
	assertEqual(t, 3, sessions.UserSessionCount(userID), "UserSessionCount after max user sessions")

	sessions = New[TestKey](2, 3, newTestKey)
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertNoError(t, err, "Add session 1")
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertNoError(t, err, "Add session 2")
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertErrorIs(t, err, ErrMaxSessions, "Add session 3, max sessions error")
	assertEqual(t, 2, sessions.SessionCount(), "SessionCount after max sessions")
}

func TestCreateLink(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)

	var sessionID TestKey
	var err error

	sessionID, err = sessions.Create(time.Minute)
	assertNoError(t, err, "Create session")
	assertNotEmpty(t, string(sessionID), "SessionID should not be empty")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after create")

	var userID = newTestKey()
	err = sessions.Link(sessionID, userID, true)
	assertNoError(t, err, "Link session")
	assertEqual(t, 1, sessions.UserSessionCount(userID), "UserSessionCount after link")

	var retUserID TestKey
	var found bool
	retUserID, found = sessions.UserID(sessionID)
	assertTrue(t, found, "UserID found after link")
	assertEqual(t, userID, retUserID, "User ID returned")

	// Test max user sessions with Link
	var userID2 = newTestKey()
	var sessionID_1 TestKey
	sessionID_1, err = sessions.CreateLinked(userID2, time.Minute)
	assertNoError(t, err, "Add session 1")
	var sessionID_2 TestKey
	sessionID_2, err = sessions.CreateLinked(userID2, time.Minute)
	assertNoError(t, err, "Add session 2")

	var sessionID2 TestKey
	sessionID2, err = sessions.Create(time.Minute)
	assertNoError(t, err, "Create session 2")

	err = sessions.Link(sessionID2, userID2, true)
	assertErrorIs(t, err, ErrMaxUserSessions, "Link session 3, max user sessions error")
	assertEqual(t, 4, sessions.SessionCount(), "SessionCount after max user sessions attempted via link")
	assertEqual(t, 3, sessions.UserSessionCount(userID2), "UserSessionCount after max user sessions attempted via link")

	// Test linking non-existent session
	var sessionID3 = newTestKey()
	var err2 error
	err2 = sessions.Link(sessionID3, userID, true)
	assertErrorIs(t, err2, ErrNotFound, "Link non-existent session")

	//Cleanup
	sessions.RemoveSession(sessionID)
	sessions.RemoveSession(sessionID_1)
	sessions.RemoveSession(sessionID_2)
	sessions.RemoveSession(sessionID2)
}

func TestUserID(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()

	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Minute)
	var retUserID TestKey
	var found bool
	retUserID, found = sessions.UserID(sessionID)
	assertTrue(t, found, "UserID found")
	assertEqual(t, userID, retUserID, "UserID returned")

	_, found = sessions.UserID(newTestKey())
	assertFalse(t, found, "UserID not found for unknown session")
}

func TestExtend(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*100)

	time.Sleep(time.Millisecond * 50)
	var err error
	err = sessions.Extend(sessionID)
	assertNoError(t, err, "Extend session")

	time.Sleep(time.Millisecond * 50)
	var _, found = sessions.UserID(sessionID)
	assertTrue(t, found, "Session should be extended") // This line was failing

	time.Sleep(time.Second)
	_, found = sessions.UserID(sessionID)
	assertFalse(t, found, "Session should timeout eventually")

	err = sessions.Extend(newTestKey())
	assertErrorIs(t, err, ErrNotFound, "Extend unknown session")
}

func TestRemoveSession(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Minute)

	var err error
	err = sessions.RemoveSession(sessionID)
	assertNoError(t, err, "RemoveSession")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after RemoveSession")
	assertEqual(t, 0, sessions.UserSessionCount(userID), "UserSessionCount after RemoveSession")

	err = sessions.RemoveSession(newTestKey())
	assertNoError(t, err, "RemoveSession unknown session")
}

func TestRemoveUser(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID1 = newTestKey()
	var userID2 = newTestKey()

	var sessionID1 TestKey
	sessionID1, _ = sessions.CreateLinked(userID1, time.Minute)
	var sessionID2 TestKey
	sessionID2, _ = sessions.CreateLinked(userID1, time.Minute)
	var sessionID3 TestKey
	sessionID3, _ = sessions.CreateLinked(userID2, time.Minute)

	var err error
	err = sessions.RemoveUser(userID1)
	assertNoError(t, err, "RemoveUser userID1")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after RemoveUser userID1")
	assertEqual(t, 0, sessions.UserSessionCount(userID1), "UserSessionCount after RemoveUser userID1")
	assertEqual(t, 1, sessions.UserSessionCount(userID2), "UserSessionCount for userID2 after RemoveUser userID1")
	var _, found = sessions.UserID(sessionID1)
	assertFalse(t, found, "SessionID1 after RemoveUser userID1")
	_, found = sessions.UserID(sessionID2)
	assertFalse(t, found, "SessionID2 after RemoveUser userID1")
	_, found = sessions.UserID(sessionID3)
	assertTrue(t, found, "SessionID3 after RemoveUser userID1")

	err = sessions.RemoveUser(userID1) // Removing non-existent user should be nil error as per implementation
	assertNoError(t, err, "RemoveUser non-existent userID1 should be no error")

	err = sessions.RemoveUser(userID2)
	assertNoError(t, err, "RemoveUser userID2")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after RemoveUser userID2")
	assertEqual(t, 0, sessions.UserSessionCount(userID2), "UserSessionCount after RemoveUser userID2")
	_, found = sessions.UserID(sessionID3)
	assertFalse(t, found, "SessionID3 after RemoveUser userID2")
}

func TestSessionCount(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	assertEqual(t, 0, sessions.SessionCount(), "Initial SessionCount")

	sessions.CreateLinked(newTestKey(), time.Minute)
	sessions.CreateLinked(newTestKey(), time.Minute)
	assertEqual(t, 2, sessions.SessionCount(), "SessionCount after adding 2 sessions")

	var sessionID TestKey // Define sessionID
	// Iterate through the sessionToUser map to get a sessionID
	for sessionID = range sessions.sessionToUser {
		break // Just get the first one
	}
	sessions.RemoveSession(sessionID)

	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after removing 1 session")
}

func TestUserSessionCount(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()
	assertEqual(t, 0, sessions.UserSessionCount(userID), "Initial UserSessionCount")

	sessions.CreateLinked(userID, time.Minute)
	sessions.CreateLinked(userID, time.Minute)
	assertEqual(t, 2, sessions.UserSessionCount(userID), "UserSessionCount after adding 2 sessions")

	var sessionID TestKey
	var found bool
	var f = func() (sessionIDRet TestKey, foundRet bool) {
		for k, u := range sessions.sessionToUser {
			if u == userID {
				sessionIDRet = k
				foundRet = true
				return
			}
		}
		return
	}
	sessionID, found = f()
	assertTrue(t, found, "SessionID found for userID")
	sessions.RemoveSession(sessionID)
	assertEqual(t, 1, sessions.UserSessionCount(userID), "UserSessionCount after removing 1 session")
}

func TestTimeout(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*100)

	time.Sleep(time.Millisecond * 200) // Wait for timeout
	var _, found = sessions.UserID(sessionID)
	assertFalse(t, found, "UserID after timeout")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after timeout")
	assertEqual(t, 0, sessions.UserSessionCount(userID), "UserSessionCount after timeout")
}

func TestConcurrentAddExtendTimeout(t *testing.T) {
	var sessions = New[TestKey](100, 10, newTestKey)
	var userID = newTestKey()
	var sessionIDs []TestKey
	var wg sync.WaitGroup
	var mu sync.Mutex

	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			var sessionID TestKey
			sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*200)
			mu.Lock()
			sessionIDs = append(sessionIDs, sessionID)
			mu.Unlock()
			time.Sleep(time.Millisecond * time.Duration(generateRandomNumber(100))) // Simulate activity
			var err = sessions.Extend(sessionID)
			if err != nil {
				fmt.Println("Extend error: ", err)
			}
		}()
	}
	wg.Wait()
	time.Sleep(time.Second) // Wait for timeouts
	assertLessOrEqual(t, sessions.SessionCount(), 50, "SessionCount in concurrent test") // Some sessions might have timed out
}

func generateRandomNumber(max int) (num int) {
	var n, err = rand.Int(rand.Reader, big.NewInt(int64(max)))
	if err != nil {
		panic(err)
	}
	num = int(n.Int64())
	return
}

func BenchmarkAdd(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var userID = newTestKey()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.CreateLinked(userID, time.Minute)
	}
}

func BenchmarkUserID(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.UserID(sessionIDs[i])
	}
}

func BenchmarkExtend(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.Extend(sessionIDs[i])
	}
}

func BenchmarkRemoveSession(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.RemoveSession(sessionIDs[i])
	}
}

func BenchmarkAddConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var userID = newTestKey()
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			sessions.CreateLinked(userID, time.Minute)
		}
	})
}

func BenchmarkUserIDConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.UserID(sessionID)
		}
	})
}

func BenchmarkExtendConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.Extend(sessionID)
		}
	})
}

func BenchmarkRemoveSessionConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.RemoveSession(sessionID)
		}
	})
}
