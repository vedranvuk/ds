// Copyright 2025 Vedran Vuk. All rights reserved.
// Use of this source code is governed by a MIT
// license that can be found in the LICENSE file.
//
// This code was generated by an AI assistant.
package sessions

import (
	"crypto/rand"
	"errors"
	"fmt"
	"math/big"
	"strconv"
	"sync"
	"sync/atomic"
	"testing"
	"time"
)

type TestKey string

var keyCounter int64

func newTestKey() (key TestKey) {
	atomic.AddInt64(&keyCounter, 1)
	key = TestKey(generateRandomString(10) + strconv.FormatInt(keyCounter, 10))
	return
}

func generateRandomString(length int) (str string) {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var b = make([]byte, length)
	for i := range b {
		var idx, err = rand.Int(rand.Reader, big.NewInt(int64(len(charset))))
		if err != nil {
			panic(err) // handle error appropriately
		}
		b[i] = charset[idx.Int64()]
	}
	str = string(b)
	return
}

func assertEqual[T comparable](t *testing.T, expected, actual T, msg string) {
	if actual != expected {
		t.Errorf("%s: expected [%v], actual [%v]", msg, expected, actual)
	}
}

func assertNotNil(t *testing.T, actual interface{}, msg string) {
	if actual == nil {
		t.Errorf("%s: should not be nil", msg)
	}
}

func assertNotEmpty(t *testing.T, actual string, msg string) {
	if actual == "" {
		t.Errorf("%s: should not be empty", msg)
	}
}

func assertTrue(t *testing.T, actual bool, msg string) {
	if !actual {
		t.Errorf("%s: should be true", msg)
	}
}

func assertFalse(t *testing.T, actual bool, msg string) {
	if actual {
		t.Errorf("%s: should be false", msg)
	}
}

func assertNoError(t *testing.T, err error, msg string) {
	if err != nil {
		t.Errorf("%s: unexpected error [%v]", msg, err)
	}
}

func assertErrorIs(t *testing.T, err, target error, msg string) {
	if !errors.Is(err, target) {
		t.Errorf("%s: error [%v] is not [%v]", msg, err, target)
	}
}

func assertLessOrEqual(t *testing.T, actual, expected int, msg string) {
	if actual > expected {
		t.Errorf("%s: actual [%d] is not less or equal to expected [%d]", msg, actual, expected)
	}
}

func TestNew(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	assertNotNil(t, sessions, "New Sessions")
	assertEqual(t, 0, sessions.SessionCount(), "Initial SessionCount")
}

func TestAdd(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()

	var sessionID TestKey
	var err error

	sessionID, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session")
	assertNotEmpty(t, string(sessionID), "SessionID should not be empty")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after add")
	assertEqual(t, 1, sessions.UserSessionCount(userID), "UserSessionCount after add")

	_, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session 2")
	_, err = sessions.CreateLinked(userID, time.Minute)
	assertNoError(t, err, "Add session 3")
	_, err = sessions.CreateLinked(userID, time.Minute)
	assertErrorIs(t, err, ErrMaxUserSessions, "Add session 4, max user sessions error")
	assertEqual(t, 3, sessions.SessionCount(), "SessionCount after max user sessions")
	assertEqual(t, 3, sessions.UserSessionCount(userID), "UserSessionCount after max user sessions")

	sessions = New[TestKey](2, 3, newTestKey, nil)
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertNoError(t, err, "Add session 1")
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertNoError(t, err, "Add session 2")
	_, err = sessions.CreateLinked(newTestKey(), time.Minute)
	assertErrorIs(t, err, ErrMaxSessions, "Add session 3, max sessions error")
	assertEqual(t, 2, sessions.SessionCount(), "SessionCount after max sessions")
}

func TestCreateLink(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)

	var sessionID TestKey
	var err error

	sessionID, err = sessions.Create(time.Minute)
	assertNoError(t, err, "Create session")
	assertNotEmpty(t, string(sessionID), "SessionID should not be empty")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after create")

	var userID = newTestKey()
	err = sessions.Link(sessionID, userID, true)
	assertNoError(t, err, "Link session")
	assertEqual(t, 1, sessions.UserSessionCount(userID), "UserSessionCount after link")

	var retUserID TestKey
	var found bool
	retUserID, found = sessions.UserID(sessionID)
	assertTrue(t, found, "UserID found after link")
	assertEqual(t, userID, retUserID, "User ID returned")

	// Test max user sessions with Link
	var userID2 = newTestKey()
	var sessionID_1 TestKey
	sessionID_1, err = sessions.CreateLinked(userID2, time.Minute)
	assertNoError(t, err, "Add session 1")
	var sessionID_2 TestKey
	sessionID_2, err = sessions.CreateLinked(userID2, time.Minute)
	assertNoError(t, err, "Add session 2")
	var sessionID_3 TestKey
	sessionID_3, err = sessions.CreateLinked(userID2, time.Minute)
	assertNoError(t, err, "Add session 3")
	_ = sessionID_3

	var sessionID_4 TestKey
	sessionID_4, err = sessions.Create(time.Minute)
	assertNoError(t, err, "Create session 4")

	err = sessions.Link(sessionID_4, userID2, true)
	assertErrorIs(t, err, ErrMaxUserSessions, "Link session 3, max user sessions error")
	assertEqual(t, 5, sessions.SessionCount(), "SessionCount after max user sessions attempted via link")
	assertEqual(t, 3, sessions.UserSessionCount(userID2), "UserSessionCount after max user sessions attempted via link")

	// Test linking non-existent session
	var sessionID3 = newTestKey()
	var err2 error
	err2 = sessions.Link(sessionID3, userID, true)
	assertErrorIs(t, err2, ErrNotFound, "Link non-existent session")

	//Cleanup
	sessions.RemoveSession(sessionID)
	sessions.RemoveSession(sessionID_1)
	sessions.RemoveSession(sessionID_2)
	sessions.RemoveSession(sessionID_3)
}

func TestUserID(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()

	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Minute)
	var retUserID TestKey
	var found bool
	retUserID, found = sessions.UserID(sessionID)
	assertTrue(t, found, "UserID found")
	assertEqual(t, userID, retUserID, "User ID returned")

	_, found = sessions.UserID(newTestKey())
	assertFalse(t, found, "UserID not found for unknown session")
}

func TestExtend(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*100)

	time.Sleep(time.Millisecond * 50)
	var err error
	err = sessions.Extend(sessionID)
	assertNoError(t, err, "Extend session")

	time.Sleep(time.Millisecond * 50)
	var _, found = sessions.UserID(sessionID)
	assertTrue(t, found, "Session should be extended") // This line was failing

	time.Sleep(time.Second)
	_, found = sessions.UserID(sessionID)
	assertFalse(t, found, "Session should timeout eventually")

	err = sessions.Extend(newTestKey())
	assertErrorIs(t, err, ErrNotFound, "Extend unknown session")
}

func TestRemoveSession(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Minute)

	var err error
	err = sessions.RemoveSession(sessionID)
	assertNoError(t, err, "RemoveSession")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after RemoveSession")
	assertEqual(t, 0, sessions.UserSessionCount(userID), "UserSessionCount after RemoveSession")

	err = sessions.RemoveSession(newTestKey())
	assertNoError(t, err, "RemoveSession unknown session")
}

func TestRemoveUser(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID1 = newTestKey()
	var userID2 = newTestKey()

	var sessionID1 TestKey
	sessionID1, _ = sessions.CreateLinked(userID1, time.Minute)
	var sessionID2 TestKey
	sessionID2, _ = sessions.CreateLinked(userID1, time.Minute)
	var sessionID3 TestKey
	sessionID3, _ = sessions.CreateLinked(userID2, time.Minute)

	var err error
	err = sessions.RemoveUser(userID1)
	assertNoError(t, err, "RemoveUser userID1")
	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after RemoveUser userID1")
	assertEqual(t, 0, sessions.UserSessionCount(userID1), "UserSessionCount after RemoveUser userID1")
	assertEqual(t, 1, sessions.UserSessionCount(userID2), "UserSessionCount for userID2 after RemoveUser userID1")
	var _, found = sessions.UserID(sessionID1)
	assertFalse(t, found, "SessionID1 after RemoveUser userID1")
	_, found = sessions.UserID(sessionID2)
	assertFalse(t, found, "SessionID2 after RemoveUser userID1")
	_, found = sessions.UserID(sessionID3)
	assertTrue(t, found, "SessionID3 after RemoveUser userID1")

	err = sessions.RemoveUser(userID1) // Removing non-existent user should be nil error as per implementation
	assertNoError(t, err, "RemoveUser non-existent userID1 should be no error")

	err = sessions.RemoveUser(userID2)
	assertNoError(t, err, "RemoveUser userID2")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after RemoveUser userID2")
	assertEqual(t, 0, sessions.UserSessionCount(userID2), "UserSessionCount after RemoveUser userID2")
	_, found = sessions.UserID(sessionID3)
	assertFalse(t, found, "SessionID3 after RemoveUser userID2")
}

func TestSessionCount(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	assertEqual(t, 0, sessions.SessionCount(), "Initial SessionCount")

	sessions.CreateLinked(newTestKey(), time.Minute)
	sessions.CreateLinked(newTestKey(), time.Minute)
	assertEqual(t, 2, sessions.SessionCount(), "SessionCount after adding 2 sessions")

	var sessionID TestKey // Define sessionID
	// Iterate through the sessionToUser map to get a sessionID
	for sessionID = range sessions.sessionToUser {
		break // Just get the first one
	}
	sessions.RemoveSession(sessionID)

	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after removing 1 session")
}

func TestUserSessionCount(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()
	assertEqual(t, 0, sessions.UserSessionCount(userID), "Initial UserSessionCount")

	sessions.CreateLinked(userID, time.Minute)
	sessions.CreateLinked(userID, time.Minute)
	assertEqual(t, 2, sessions.SessionCount(), "SessionCount after adding 2 sessions")

	var sessionID TestKey // Define sessionID
	// Iterate through the sessionToUser map to get a sessionID
	for sessionID = range sessions.sessionToUser {
		break // Just get the first one
	}
	sessions.RemoveSession(sessionID)

	assertEqual(t, 1, sessions.SessionCount(), "SessionCount after removing 1 session")
}

func TestUserSessions(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()

	// No sessions for user
	var sessionIDs = sessions.UserSessions(userID)
	assertEqual(t, 0, len(sessionIDs), "Initial UserSessions count")

	// Add sessions for user
	var sessionID1 TestKey
	sessionID1, _ = sessions.CreateLinked(userID, time.Minute)
	var sessionID2 TestKey
	sessionID2, _ = sessions.CreateLinked(userID, time.Minute)

	sessionIDs = sessions.UserSessions(userID)
	assertEqual(t, 2, len(sessionIDs), "UserSessions count after adding 2 sessions")

	// Check if session IDs are correct
	var found1, found2 bool
	for _, sessionID := range sessionIDs {
		if sessionID == sessionID1 {
			found1 = true
		}
		if sessionID == sessionID2 {
			found2 = true
		}
	}
	assertTrue(t, found1, "SessionID1 found in UserSessions")
	assertTrue(t, found2, "SessionID2 found in UserSessions")

	// Remove a session and check again
	sessions.RemoveSession(sessionID1)
	sessionIDs = sessions.UserSessions(userID)
	assertEqual(t, 1, len(sessionIDs), "UserSessions count after removing 1 session")

	// Check if remaining session ID is correct
	assertEqual(t, sessionID2, sessionIDs[0], "Remaining session ID is correct")
}

func TestTimeoutCallback(t *testing.T) {
	var timeoutCalled int32
	var sessions = New[TestKey](10, 3, newTestKey, func(sessionID TestKey) {
		atomic.AddInt32(&timeoutCalled, 1)
	})
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*100)

	time.Sleep(time.Millisecond * 200) // Wait for timeout
	var _, found = sessions.UserID(sessionID)
	assertFalse(t, found, "UserID after timeout")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after timeout")
	assertEqual(t, 0, sessions.UserSessionCount(userID), "UserSessionCount after timeout")
	assertEqual(t, int32(1), atomic.LoadInt32(&timeoutCalled), "Timeout callback should be called")
}

func TestTimeout(t *testing.T) {
	var sessions = New[TestKey](10, 3, newTestKey, nil)
	var userID = newTestKey()
	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*100)

	time.Sleep(time.Millisecond * 200) // Wait for timeout
	var _, found = sessions.UserID(sessionID)
	assertFalse(t, found, "UserID after timeout")
	assertEqual(t, 0, sessions.SessionCount(), "SessionCount after timeout")
	assertEqual(t, 0, sessions.UserSessionCount(userID), "UserSessionCount after timeout")
}

func TestConcurrentAddExtendTimeout(t *testing.T) {
	var sessions = New[TestKey](100, 10, newTestKey, nil)
	var userID = newTestKey()
	var sessionIDs []TestKey
	var wg sync.WaitGroup
	var mu sync.Mutex

	var sessionID TestKey
	sessionID, _ = sessions.CreateLinked(userID, time.Millisecond*200)
	for i := 0; i < 50; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			mu.Lock()
			sessionIDs = append(sessionIDs, sessionID)
			mu.Unlock()
			time.Sleep(time.Millisecond * time.Duration(generateRandomNumber(100))) // Simulate activity
			var err = sessions.Extend(sessionID)
			if err != nil {
				fmt.Println("Extend error: ", err)
			}
		}()
	}
	wg.Wait()
	time.Sleep(time.Second) // Wait for timeouts
	assertLessOrEqual(t, sessions.SessionCount(), 50, "SessionCount in concurrent test") // Some sessions might have timed out
}

func generateRandomNumber(max int) (num int) {
	var n, err = rand.Int(rand.Reader, big.NewInt(int64(max)))
	if err != nil {
		panic(err)
	}
	num = int(n.Int64())
	return
}

func BenchmarkAdd(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var userID = newTestKey()
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.CreateLinked(userID, time.Minute)
	}
}

func BenchmarkUserID(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.UserID(sessionIDs[i])
	}
}

func BenchmarkExtend(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.Extend(sessionIDs[i])
	}
}

func BenchmarkRemoveSession(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		sessions.RemoveSession(sessionIDs[i])
	}
}

func BenchmarkAddConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var userID = newTestKey()
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			sessions.CreateLinked(userID, time.Minute)
		}
	})
}

func BenchmarkUserIDConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.UserID(sessionID)
		}
	})
}

func BenchmarkExtendConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.Extend(sessionID)
		}
	})
}

func BenchmarkRemoveSessionConcurrent(b *testing.B) {
	var sessions = New[TestKey](b.N, 1, newTestKey, nil)
	var sessionIDs = make([]TestKey, b.N)
	var userID = newTestKey()
	for i := 0; i < b.N; i++ {
		sessionIDs[i], _ = sessions.CreateLinked(userID, time.Minute)
	}
	b.ResetTimer()
	b.RunParallel(func(pb *testing.PB) {
		for pb.Next() {
			var sessionID = sessionIDs[generateRandomNumber(b.N)] // Randomly pick a session
			sessions.RemoveSession(sessionID)
		}
	})
}
